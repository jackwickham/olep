package net.jackw.olep.metrics;

import com.fasterxml.jackson.databind.ObjectMapper;
import net.jackw.olep.common.DatabaseConfig;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.UncheckedIOException;
import java.nio.charset.StandardCharsets;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * Singleton for managing all of the metrics generated by the program
 */
public class MetricsManager {
    /**
     * The data is being written fast, so reduce the number of flushes by increasing the buffer size
     */
    private static final int WRITE_BUFFER_SIZE = 65536;

    private BufferedWriter durationWriter;
    private BufferedWriter eventWriter;

    private MetricsManager(String mainClass, DatabaseConfig config) throws IOException {
        // First make the results dir
        String date = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss").format(new Date());
        File resultsDir = new File(String.format(
            "%s/%s-%d-%s/", config.getResultsDir(), date, config.getWarehouseCount(), mainClass
        ));
        if (!resultsDir.mkdirs()) {
            throw new IOException("Failed to create results dir " + resultsDir.getPath());
        }

        // Create the file of duration events
        durationWriter = new BufferedWriter(new OutputStreamWriter(
            new FileOutputStream(new File(resultsDir, "durations.csv")), StandardCharsets.UTF_8
        ), WRITE_BUFFER_SIZE);
        durationWriter.write("t,event,duration\n");

        // And the file of instantaneous events
        eventWriter = new BufferedWriter(new OutputStreamWriter(
            new FileOutputStream(new File(resultsDir, "events.csv")), StandardCharsets.UTF_8
        ), WRITE_BUFFER_SIZE);
        eventWriter.write("t,event\n");

        // Also copy the config file to the results dir, to allow easy checking that it is the correct benchmark
        new ObjectMapper().writerWithDefaultPrettyPrinter().writeValue(new File(resultsDir, "config.json"), config);

        // Close the files once we finish
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            try {
                durationWriter.close();
                eventWriter.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }));
    }

    private static MetricsManager instance;

    /**
     * Set up the metrics. This should be called exactly once per program launch
     *
     * @param mainClass An identifier for the main class that was used
     * @param config The active database config
     * @throws IOException If unable to write to any of the files
     * @throws IllegalStateException If this method is called more than once
     */
    public static void initialise(String mainClass, DatabaseConfig config) throws IOException {
        if (instance != null) {
            throw new IllegalStateException("Metrics manager must only be initialised once");
        }
        instance = new MetricsManager(mainClass, config);
    }

    /**
     * Get the current instance of MetricsManager. This method can only be called after {@link #initialise(String, DatabaseConfig)}
     */
    public static MetricsManager getInstance() {
        if (instance == null) {
            throw new IllegalStateException("Metrics manager needs to be initialised with the database config before it can be used");
        }
        return instance;
    }

    /**
     * Start a new timer
     */
    public Timer startTimer() {
        return Timer.start();
    }

    /**
     * Record a duration
     *
     * @param type The type of duration event that this corresponds to
     * @param timer The timer that was started when the event started
     */
    public void recordDuration(DurationType type, Timer timer) {
        long duration = timer.getElapsed();
        String line = System.currentTimeMillis() + "," + type.toString() + "," + duration + "\n";
        try {
            durationWriter.write(line);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    /**
     * Record an instantaneous event
     *
     * @param type The type of event that is being recorded
     */
    public void recordEvent(EventType type) {
        String line = System.currentTimeMillis() + "," + type.toString() + "\n";
        try {
            eventWriter.write(line);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }
}
